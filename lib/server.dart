library spark_server;

import 'dart:io';
import 'dart:async';
import 'dart:convert';
import 'package:sparkflow/sparkflow.dart';
import 'package:spark_fs/fs.dart';
import 'package:rio/rio.dart';
import 'package:hub/hub.dart';

export 'package:rio/rio.dart';
export 'package:sparkflow/sparkflow.dart';
export 'package:spark_fs/fs.dart';


class Server{

  static bool isWebSocket(w) => w is WebSocket;
  static bool isHttpRequest(w) => w is HttpRequest;

  static void register(){
      
     Fs.register();

     Sparkflow.createRegistry('spark.server',(r){

       r.addMutation('utils/serverConsole',(e){
         e.meta('desc','prints details out into the console');

         e.sd.add('proc',Funcs.compose((n) => e.sd.get('printer')(n),
             (n) => e.sd.get('formater')(n)));

         e.sd.add('printer',print);
         e.sd.add('formater',(n){
            var r = n.data;
            if(r is Rio) r = r.req;
            var buff = new StringBuffer();
            buff.write('HttpRequest -> Address: ${r.headers.value("host")} Method: ${r.method}');
            buff.write('\n\t URI: ${r.uri.path}');
            buff.write('\n\t RemoteAddress: ${r.connectionInfo.remoteAddress}');
            buff.write('\n\t Local Port: ${r.connectionInfo.localPort}');
            buff.write('\n\t Remote Port: ${r.connectionInfo.remotePort}');
            buff.write('\n');
            return buff.toString();
         });

         e.makeInport('in:req');
         e.makeInport('in:printer');
         e.makeInport('in:formater');

         e.port('in:printer').forceCondition(Valids.isFunction);
         e.port('in:formater').forceCondition(Valids.isFunction);
         e.port('in:req').forceCondition(Server.isHttpRequest);

         e.tap('in:printer',(n){
            e.sd.update('printer',n.data);
         });
         
         e.tap('in:formater',(n){
            e.sd.update('formater',n.data);
         });

         e.tap('in:req',e.sd.get('proc'));

       });

       r.addMutation('protocols/http',(e){
          e.meta('desc','provies a basic dart HttpServer');

          var conf = MapDecorator.create();
          e.sd.add('dconf',{ 'host': '127.0.0.1','port':3000 });
          e.sd.add('conf',null);

          e.makeOutport('io:req',meta:{'desc':'sends out all request generated by these server object'});
          e.makeInport('debug:boot',meta:{'desc':'bootsup the server with default routes'});
          e.makeInport('io:conf',meta:{ 
            'desc':'accepts a map of configs options eg. port, hostname/address'
          });
          e.makeOutport('io:server',meta:{'desc': 'sends of the server object for those who care '});
          e.makeOutport('io:error',meta:{'desc':'sends out all errors generated by these server object'});

          e.port('debug:boot').tap((n){
             e.port('io:conf').send(e.sd.get('dconf'));
          });

          e.port('io:conf').forceCondition(Valids.isMap);
          e.port('io:conf').forceCondition((n){
            if(n.containsKey('port')){
              if(n['port'] is int) return true;
              e.send('io:error',"""
                "$n , port must be a number eg 4000,300";
              """);
              return false;
            }
          });

          e.port('io:conf').tap((n){
            if(e.sd.has('server') && Valids.exist(e.sd.get('server'))) e.sd.get('server').close();
            var cf = Enums.merge(n.data,e.sd.get('dconf'),override:false);
            conf.storage = cf;
            e.sd.update('conf',cf);

            HttpServer.bind(conf.get('host'),conf.get('port')).then((s){
               e.sd.update('server',s);
               e.port('io:server').send(s);
               s.listen((r){
                 e.port('io:req').send(r);
                 e.port('io:server').endStream();
               });
            }).catchError(e.port('io:error').send);
          });

       });

       r.addMutation('protocols/websocks',(e){
          e.meta('desc','turns every request into a websocket to be send off');

          e.createSpace('conf');
          e.createSpace('io');

          e.makeInport('conf:meta',meta:{});
          e.makeInport('io:req',meta:{});
          e.makeInport('io:error',meta:{});
          e.makeOutport('io:socket',meta:{});
           
          e.sd.add('sockets',[]);
          e.sd.add('conf',{
            'max':10000000000000,
          });

          e.port('io:req').forceCondition(Server.isHttpRequest);
          e.port('io:req').forceCondition((n){
             if(e.sd.get('sockets').length >= e.sd.get('conf')['max']) return false;
             return true;
          });

          e.port('conf:meta').tap((n){
             if(e.sd.get('sockets').length >= e.sd.get('conf')['max']);
          });

          e.port('io:req').tap((n){
              WebSocketTransformer.upgrade(n.data).then((w){
                e.sd.get('sockets').add(w);
                e.port('io:socket').send(w);
              }).catchError(e.port('io:error').send);
              e.port('io:req').endStream();
          });


       });


       r.addMutation('protocols/websockboy',(e){
          e.meta('desc','lowe level websocket operation component');

          e.createSpace('io');
          e.makeInport('io:socks');
          e.makeInport('io:processor');
          e.makeOutport('io:stream');

          e.sd.add('_proc',(r){ e.sd.get('processor')(r,e); });
          e.sd.add('processor',(e,m){ return null; });

          e.port('io:processor').forceCondition(Valids.isFunction);
          e.port('io:socks').tap((n){
            e.sd.update('processor',n.data);
          });

          e.port('io:socks').forceCondition(Server.isWebSocket);
          e.port('io:socks').forceCondition((m) => Valids.notExist(e.sd.has('socket')));
          e.port('io:socks').tap((n){
            e.sd.update('socket',n.data);
            n.data.listen(e.sd.get('_proc'));
          });

       });

       r.addMutation('protocols/routeboy',(e){
          e.meta('desc','filters request dependent on paramters passed');

          e.createSpace('io');
          e.makeInport('io:req');
          e.makeInport('io:conf');
          e.makeOutport('io:stream');

          var param = MapDecorator.create();
          e.port('io:conf').forceCondition(Valids.isMap);
          e.port('io:conf').forceCondition((m){
            if(m.containsKey('route') && m['route'] is RegExp) return true;
            return false;
          });

          e.port('io:conf').tap((n){
            e.sd.update('param',n.data);
            param.storage = n.data;
          });

          e.port('io:req').forceCondition((r){
            if(param.get('route').hasMatch(r.uri.path)) return true;
            return false;
          });

          e.port('io:req').bindPort(e.port('io:stream'));
       });

       r.addMutation('protocol/antiroutes',(e){
  
          var list = [];
          e.sd.update('list',list);

          e.createInport('io:routes');
          e.createInport('io:req');
          e.createOutport('io:stream');

          e.port('io:routes').forceCondition(Valids.isRegExp);
          e.port('io:req').forceCondition(Server.isHttpRequest);

          e.tap('io:routes',(n){
             if(!list.contains(n.data))
               list.add(n.data);
          });

          e.tap('io:req',(n){
            Enums.eachAsync(list,(e,i,o,fn){
                if(e.hasMatch(n.data)) return fn(true);
                return fn(null);
            },(_,err){
              if(Valids.exist(err)) return null;
               e.port('io:stream').send(n.data);
            });
          });

       });

       r.addMutation('protocols/responseboy',(e){
          e.meta('desc','filters request dependent on paramters passed');
  
          var req = Rio.create(), 
              param = MapDecorator.create(),
              init = (param,req) => e.sd.get('proc')(param,req);

          e.sd.add('req',req);
          e.makeInport('io:conf');
          e.makeInport('io:proc');
          e.makeInport('io:stream');

          e.loopPorts('static:option','io:conf');

          e.port('io:conf').forceCondition(Valids.isMap);
          e.port('io:proc').forceCondition(Valids.isFunction);

          e.port('io:proc').pause();

          e.port('io:conf').tap((n){
            e.sd.update('conf',n.data);
            param.storage = n.data;
            e.port('io:proc').resume();
          });

          e.port('io:stream').pause();

          e.port('io:proc').tap((n){
            e.port('io:stream').pause();
            e.sd.update('proc',n.data);
            init(param,req);
            e.port('io:stream').resume();
          });

          e.port('io:stream').tap((n){
            req.use(n.data);
          });

       });

       r.addMutation('protocols/_virtualFSRule',(e){

          e.sd.add('conf',MapDecorator.create());
          var conf = e.sd.get('conf');
          
          e.createSpace('io');

          e.createProxyOutport('io:errors');

          e.createProxyInport('io:conf');
          e.createProxyInport('io:path');

          e.createProxyInport('io:readkick');
          e.createProxyInport('io:writekick');

          e.createProxyOutport('io:readStream');
          e.createProxyInport('io:writeStream');

          e.port('io:readkick').pause();
          e.port('io:writekick').pause();

       });

       r.addBaseMutation('protocols/_virtualFSRule','protocols/virtualdir',(e){
          e.meta('desc','component to handle all fs operations');

          var conf = e.sd.get('conf');

          e.network.add('spark.fs/protocols/opendir','rd');
          e.network.add('spark.fs/protocols/writedir','wd');

          e.network.ensureBinding('*','io:conf','rd','io:conf');
          e.network.ensureBinding('*','io:conf','wd','io:conf');

          e.network.ensureBinding('*','io:path','rd','io:path');
          e.network.ensureBinding('*','io:path','wd','io:path');

          e.network.ensureBinding('*','io:readkick','rd','io:kick');
          e.network.ensureBinding('*','io:writekick','wd','io:kick');
          
          e.network.ensureBinding('rd','io:stream','*','io:readStream');
          e.network.ensureBinding('*','io:writeStream','wd','io:stream');

          e.network.ensureBinding('rd','io:error','*','io:errors');
          e.network.ensureBinding('wd','io:error','*','io:errors');

          e.network.whenAlive.then((_){
            e.port('io:readkick').resume();
            e.port('io:writekick').resume();
          });

       });

       r.addBaseMutation('protocols/_virtualFSRule','protocols/virtualfile',(e){
          e.meta('desc','component to handle all fs operations');

          var conf = e.sd.get('conf');
          
          e.network.add('spark.fs/protocols/appendfile','ap');
          e.network.add('spark.fs/protocols/openfile','op');

          e.network.ensureBinding('*','io:conf','op','io:conf');
          e.network.ensureBinding('*','io:conf','ap','io:conf');

          e.network.ensureBinding('*','io:path','op','io:path');
          e.network.ensureBinding('*','io:path','ap','io:path');

          e.network.ensureBinding('*','io:readkick','op','io:kick');
          e.network.ensureBinding('*','io:writekick','ap','io:kick');
          
          e.network.ensureBinding('op','io:stream','*','io:readStream');
          e.network.ensureBinding('*','io:writeStream','ap','io:stream');
          
          e.network.ensureBinding('op','io:error','*','io:errors');
          e.network.ensureBinding('ap','io:error','*','io:errors');

          e.network.whenAlive.then((_){
            e.port('io:readkick').resume();
            e.port('io:writekick').resume();
          });

       });

       r.addMutation('protocols/_baseviews',(e){
          e.meta('desc','component that provides view like facility');

          e.sd.add('conf',MapDecorator.create());

          e.createProxyInport('view:fn');
          e.createProxyInport('view:conf');
          e.createProxyInport('view:req');
          e.createProxyOutport('view:errors');

          e.port('view:fn').forceCondition(Valids.isFunction);
          e.port('view:conf').forceCondition(Valids.isMap);
          e.port('view:req').forceCondition(Server.isHttpRequest);

          e.tapData('view:conf',(n){
            e.sd.get('conf').storage = n.data;
          });
       });

       r.addBaseMutation('protocols/_baseviews','protocols/_views',(e){
          e.meta('desc','component that provides view like facility');

          e.network.add('spark.server/protocols/responseboy','rsp');

          e.network.ensureBinding('*','view:req','rsp','io:stream');
          e.network.ensureBinding('*','view:fn','rsp','io:proc');
          e.network.ensureBinding('*','view:conf','rsp','io:conf');
       });

       r.addBaseMutation('protocols/_views','protocols/viewfn',(e){
          e.meta('desc','provides a view with a function port to set up behaviour');
       });

       r.addBaseMutation('protocols/_views','protocols/pageview',(e){
          e.meta('desc','provides view rendering a file eg index.html');

          e.port('view:conf').forceCondition((n){
            if(n.containsKey('view') && n['view'] is String) return true;
            e.send('view:errors',"""
              View config must provide a value for view eg { 'view': 'detail_of_view' }
            """);
            return false;
          });

          e.send('view:fn',(p,req){
            req.enableDefaults();
            req.on('get',(r) => req.sendFile(conf.get('view')));
          });

       });

       r.addMutation('protocols/response_reader',(e){

         e.makeInport('io:req');
         e.makeOutport('io:stream');

         e.tap('io:req',(n){
              e.port('io:req').pause();
              var req = n.data;
              req.getBody().then((f){
                e.port('io:stream').send(f);
                e.port('io:stream').endStream();
                req.end();
              });
         });

         e.tapEnd('io:stream',(n){
            e.port('io:req').resume();
         });

       });

       r.addMutation('protocols/response_writer',(e){

         e.makeInport('io:req');
         e.makeInport('io:stream');

         e.port('io:stream').pause();

         e.tap('io:req',(n){
              e.sd.update('req',n.data);
              e.port('io:req').pause();
              e.port('io:stream').resume();
         });

         e.tapData('io:stream',(n){
              e.sd.get('req').send(n.data);
         });

         e.tapEnd('io:stream',(n){
            e.sd.get('req').end();
            e.port('io:req').resume();
         });

       });

       r.addBaseMutation('protocols/_baseviews','protocols/_resView',(e){
          e.meta('desc','provides a view for a file operation');

          e.createProxyOutport('view:reqStream');
          e.createProxyOutport('view:writedata');
          e.createProxyInport('view:readdata');

          e.network.add('spark.server/protocols/response_writer','rw');
          e.network.add('spark.server/protocols/response_reader','rd');

          e.network.ensureBinding('*','view:writedata','rw','io:stream');
          e.network.ensureBinding('rd','io:stream','*','view:readdata');

          var req = Rio.create();
          req.enableDefaults();

          e.sd.update('req',req);
          e.sd.update('ioconf',MapDecorator.create());

          e.tapData('view:conf',(n){
              var conf = e.sd.get('conf');
              if(Valids.not(conf.has('writable'))) conf.update('writable',false);
              if(Valids.not(conf.has('readable'))) conf.update('readable',true);
          });

          req.on('head',(f){
              e.send('view:reqStream',req);
              req.end();
          });

          req.on('get',(f){
            if(Valids.isTrue(e.sd.get('conf').get('readable'))){
                e.send('view:reqStream',req);
                e.network.send('rw','io:req',req);
             }
          });

          req.on('post',(r){
            if(Valids.isTrue(e.sd.get('conf').get('writable'))){
              e.send('view:reqStream',req);
              e.network.send('rd','io:req',req);
             }
          });

          req.on('put',(r){
            if(Valids.isTrue(e.sd.get('conf').get('writable'))){
              e.send('view:reqStream',req);
              e.network.send('rd','io:req',req);
             }
          });


          e.tapData('view:req',(n){
            req.use(n.data);
          });
       });

       r.addBaseMutation('protocols/_resView','protocols/_fsview',(e){
            var conf = e.sd.get('conf');

            e.tapData('view:conf',(n){
               var fs = {
                  'auto': (conf.has('auto') ? conf.get('auto') : false),
                  'file': conf.get('view')
              };
              e.sd.get('ioconf').storage = fs;
            });

       });

       r.addBaseMutation('protocols/_fsview','protocols/fileview',(e){

            var conf = e.sd.get('conf');

            e.network.add('spark.server/protocols/virtualfile','vd');
            e.network.add('spark.utils/utils/utf8.decode','ud');
            e.network.add('spark.utils/utils/utf8.decode','ud2');

            e.network.ensureBinding('vd','io:errors','*','view:errors');

            e.network.ensureBinding('*','view:readdata','ud2','io:in');
            e.network.ensureBinding('ud2','io:out','vd','io:writeStream');

            e.network.ensureBinding('vd','io:readStream','ud','io:in');
            e.network.ensureBinding('ud','io:out','*','view:writedata');

            var req = e.sd.get('req');
              
            req.on('get',(r){
                if(conf.get('readable'))
                  e.network.send('vd','io:readkick',true);
            });

            req.on('post',(r){
                if(conf.get('writable'))
                  e.network.send('vd','io:writekick',true);
            });

            req.on('put',(r){
                if(conf.get('writable'))
                  e.network.send('vd','io:writekick',true);
            });

            e.tapData('view:conf',(n){
                e.network.schedulePacket('vd','io:conf',e.sd.get('ioconf').core);
            });

       });

       r.addBaseMutation('protocols/_fsview','protocols/dirview',(e){

            var conf = e.sd.get('conf');

            e.network.add('spark.server/protocols/virtualdir','vd');

            e.network.ensureBinding('vd','io:errors','*','view:errors');

            e.network.ensureBinding('vd','io:readStream','*','view:writedata');
            e.network.ensureBinding('*','view:readdata','vd','io:writeStream');

            e.tap('view:readdata',(n){
                print('sending writekick');
                e.network.send('vd','io:writekick',true);
            });

            e.tap('view:writedata',(n){
                print('sending writekick');
                e.network.send('vd','io:readkick',true);
            });

            e.tapData('view:conf',(n){
                e.network.send('vd','io:conf',e.sd.get('ioconf'));
            });
       });

       r.addBaseMutation('protocols/_views','protocols/vfs_file',(e){
          e.meta('desc','provides a view for a file operation');

          e.network.add('spark.server/protocols/virtualfile','vd');
          e.network.add('spark.server/protocols/response_writer','rw');
          e.network.add('spark.server/protocols/response_reader','rd');

          e.network.ensureBinding('vd','io:errors','*','view:errors');


          e.send('view:fn',(p,req){
            
              if(Valids.not(p.has('writable'))) p.update('writable',false);
              if(Valids.not(p.has('readable'))) p.update('readable',true);

              req.enableDefaults();

              if(Valids.isTrue(p.get('readable'))){
  
                  var bits = [];
                  req.on('get',(f){
                      e.network.send('vd','io:readkick',true);
                      e.network.send('rw','io:req',req);
                  });

                  e.network.tapData('vd','io:readStream',(n){
                     e.network.send('rw','io:stream',UTF8.decode(n.data));
                  });

                  e.network.tapEnd('vd','io:readStream',(n){
                     e.network.endStream('rw','io:stream');
                  });
              }

              if(Valids.isTrue(p.get('writable'))){

                e.network.send('vd','io:writekick',true);

                  req.on('post',(r){
                    r.getBody().then((f){
                       var content = UTF8.decode(f);
                       e.network.send('vd','io:writeStream',content);
                    }).then((f){
                       req.end();
                    });
                  });
              }

          });

          e.tap('view:conf',(n){
              var conf = n.data;
              e.network.schedulePacket('vd','io:conf',{
                  'auto': (conf.containsKey('auto') ? conf['auto'] : false),
                  'file': conf['view']
              });
          });

       });


       r.addBaseMutation('protocols/_views','protocols/vfs_dir',(e){
          e.meta('desc','provides a view for a file operation');

          e.network.add('spark.server/protocols/virtualdir','vd');
          e.network.add('spark.server/protocols/response_writer','rw');
          e.network.add('spark.server/protocols/response_reader','rd');

          e.send('view:fn',(p,req){
            
              if(Valids.not(p.has('writable'))) p.update('writable',false);
              if(Valids.not(p.has('readable'))) p.update('readable',true);

              req.enableDefaults();

              if(Valids.isTrue(p.get('readable'))){
  
                  var bits = [];
                  req.on('get',(f){
                      e.network.send('rw','io:req',req);
                  });

                  e.network.tapData('vd','io:readStream',(n){
                     bits.add(n.data.path);
                  });

                  e.network.tapEnd('vd','io:readStream',(n){
                     /*e.network.send('rw','io:stream',bit);*/
                     e.network.endStream('rw','io:stream',bit);
                  });
              }

              if(Valids.isTrue(p.get('writable'))){

                e.network.send('vd','io:writekick',true);

                  req.on('post',(r){
                    r.getBody().then((f){
                       var content = UTF8.decode(f);
                       e.network.send('vd','io:writeStream',content);
                    }).then((f){
                       req.end();
                    });
                  });
              }

          });

          e.tap('view:conf',(n){
              var conf = n.data;
              e.network.schedulePacket('vd','io:conf',{
                  'auto': (conf.containsKey('auto') ? conf['auto'] : false),
                  'file': conf['view']
              });
          });

       });

     });
  }
}
