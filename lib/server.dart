library spark_server;

import 'dart:io';
import 'dart:async';
import 'package:sparkflow/sparkflow.dart';
import 'package:spark_fs/fs.dart';
import 'package:rio/rio.dart';
import 'package:hub/hub.dart';

export 'package:rio/rio.dart';
export 'package:sparkflow/sparkflow.dart';
export 'package:spark_fs/fs.dart';


class Server{

  static bool isWebSocket(w) => w is WebSocket;
  static bool isHttpRequest(w) => w is HttpRequest;

  static void register(){
      
     Fs.register();

     Sparkflow.createRegistry('spark.server',(r){

       r.addMutation('utils/serverConsole',(e){
         e.meta('desc','prints details out into the console');

         e.sd.add('proc',Funcs.compose((n) => e.sd.get('printer')(n),
             (n) => e.sd.get('formater')(n)));

         e.sd.add('printer',print);
         e.sd.add('formater',(n){
            var r = n.data;
            if(r is Rio) r = r.req;
            var buff = new StringBuffer();
            buff.write('HttpRequest -> Address: ${r.headers.value("host")} Method: ${r.method}');
            buff.write('\n\t URI: ${r.uri.path}');
            buff.write('\n\t RemoteAddress: ${r.connectionInfo.remoteAddress}');
            buff.write('\n\t Local Port: ${r.connectionInfo.localPort}');
            buff.write('\n\t Remote Port: ${r.connectionInfo.remotePort}');
            buff.write('\n');
            return buff.toString();
         });

         e.makeInport('in:req');
         e.makeInport('in:printer');
         e.makeInport('in:formater');

         e.port('in:printer').forceCondition(Valids.isFunction);
         e.port('in:formater').forceCondition(Valids.isFunction);
         e.port('in:req').forceCondition(Server.isHttpRequest);

         e.tap('in:printer',(n){
            e.sd.update('printer',n.data);
         });
         
         e.tap('in:formater',(n){
            e.sd.update('formater',n.data);
         });

         e.tap('in:req',e.sd.get('proc'));

       });

       r.addMutation('protocols/http',(e){
          e.meta('desc','provies a basic dart HttpServer');

          var conf = MapDecorator.create();
          e.sd.add('dconf',{ 'host': '127.0.0.1','port':3000 });
          e.sd.add('conf',null);

          e.makeOutport('io:req',meta:{'desc':'sends out all request generated by these server object'});
          e.makeInport('debug:boot',meta:{'desc':'bootsup the server with default routes'});
          e.makeInport('io:conf',meta:{ 'desc':'accepts a map of configs options eg. port, hostname/address' });
          e.makeOutport('io:server',meta:{'desc': 'sends of the server object for those who care '});
          e.makeOutport('io:error',meta:{'desc':'sends out all errors generated by these server object'});

          e.port('debug:boot').tap((n){
             e.port('io:conf').send(e.sd.get('dconf'));
          });

          e.port('io:conf').forceCondition(Valids.isMap);
          e.port('io:conf').forceCondition((n){
            if(n.containsKey('port')){
              if(n['port'] is int) return true;
              throw "$n , port must be a number eg 4000,300";
              return false;
            }
          });

          e.port('io:conf').tap((n){
            if(e.sd.has('server') && Valids.exist(e.sd.get('server'))) e.sd.get('server').close();
            var cf = Enums.merge(n.data,e.sd.get('dconf'),override:false);
            conf.storage = cf;
            e.sd.update('conf',cf);

            HttpServer.bind(conf.get('host'),conf.get('port')).then((s){
               e.sd.update('server',s);
               e.port('io:server').send(s);
               s.listen((r){
                 e.port('io:req').send(r);
                 e.port('io:server').endStream();
               });
            }).catchError(e.port('io:error').send);
          });

       });

       r.addMutation('protocols/websocks',(e){
          e.meta('desc','turns every request into a websocket to be send off');

          e.createSpace('conf');
          e.createSpace('io');

          e.makeInport('conf:meta',meta:{});
          e.makeInport('io:req',meta:{});
          e.makeInport('io:error',meta:{});
          e.makeOutport('io:socket',meta:{});
           
          e.sd.add('sockets',[]);
          e.sd.add('conf',{
            'max':10000000000000,
          });

          e.port('io:req').forceCondition(Server.isHttpRequest);
          e.port('io:req').forceCondition((n){
             if(e.sd.get('sockets').length >= e.sd.get('conf')['max']) return false;
             return true;
          });

          e.port('conf:meta').tap((n){
             if(e.sd.get('sockets').length >= e.sd.get('conf')['max']);
          });

          e.port('io:req').tap((n){
              WebSocketTransformer.upgrade(n.data).then((w){
                e.sd.get('sockets').add(w);
                e.port('io:socket').send(w);
              }).catchError(e.port('io:error').send);
              e.port('io:req').endStream();
          });


       });


       r.addMutation('protocols/websockboy',(e){
          e.meta('desc','lowe level websocket operation component');

          e.createSpace('io');
          e.makeInport('io:socks');
          e.makeInport('io:processor');
          e.makeOutport('io:stream');

          e.sd.add('_proc',(r){ e.sd.get('processor')(r,e); });
          e.sd.add('processor',(e,m){ return null; });

          e.port('io:processor').forceCondition(Valids.isFunction);
          e.port('io:socks').tap((n){
            e.sd.update('processor',n.data);
          });

          e.port('io:socks').forceCondition(Server.isWebSocket);
          e.port('io:socks').forceCondition((m) => Valids.notExist(e.sd.has('socket')));
          e.port('io:socks').tap((n){
            e.sd.update('socket',n.data);
            n.data.listen(e.sd.get('_proc'));
          });

       });

       r.addMutation('protocols/routeboy',(e){
          e.meta('desc','filters request dependent on paramters passed');

          e.createSpace('io');
          e.makeInport('io:req');
          e.makeInport('io:conf');
          e.makeOutport('io:stream');

          var param = MapDecorator.create();
          e.port('io:conf').forceCondition(Valids.isMap);
          e.port('io:conf').forceCondition((m){
            if(m.containsKey('route') && m['route'] is RegExp) return true;
            return false;
          });

          e.port('io:conf').tap((n){
            e.sd.update('param',n.data);
            param.storage = n.data;
          });

          e.port('io:req').forceCondition((r){
            if(param.get('route').hasMatch(r.uri.path)) return true;
            return false;
          });

          e.port('io:req').bindPort(e.port('io:stream'));
       });

       r.addMutation('protocols/responseboy',(e){
          e.meta('desc','filters request dependent on paramters passed');
  
          var req = Rio.create(), 
              param = MapDecorator.create(),
              init = (param,req) => e.sd.get('proc')(param,req);

          e.sd.add('req',req);
          e.makeInport('io:conf');
          e.makeInport('io:proc');
          e.makeInport('io:stream');

          e.loopPorts('static:option','io:conf');

          e.port('io:conf').forceCondition(Valids.isMap);
          e.port('io:proc').forceCondition(Valids.isFunction);

          e.port('io:proc').pause();

          e.port('io:conf').tap((n){
            e.sd.update('conf',n.data);
            param.storage = n.data;
            e.port('io:proc').resume();
          });

          e.port('io:stream').pause();

          e.port('io:proc').tap((n){
            e.port('io:stream').pause();
            e.sd.update('proc',n.data);
            init(param,req);
            e.port('io:stream').resume();
          });

          e.port('io:stream').tap((n){
            req.use(n.data);
          });

       });

       r.addMutation('protocols/_virtualFSRule',(e){

          e.sd.add('conf',MapDecorator.create());
          var conf = e.sd.get('conf');
          
          e.createSpace('io');

          e.createProxyOutport('io:errors');

          e.createProxyInport('io:conf');
          e.createProxyInport('io:path');

          e.createProxyInport('io:readkick');
          e.createProxyInport('io:writekick');

          e.createProxyOutport('io:readStream');
          e.createProxyInport('io:writeStream');

          e.port('io:readkick').pause();
          e.port('io:writekick').pause();

       });

       r.addBaseMutation('protocols/_virtualFSRule','protocols/virtualdir',(e){
          e.meta('desc','component to handle all fs operations');

          var conf = e.sd.get('conf');

          e.network.add('spark.fs/protocols/opendir','rd');
          e.network.add('spark.fs/protocols/writedir','wd');

          e.network.ensureBinding('*','io:conf','rd','io:conf');
          e.network.ensureBinding('*','io:conf','wd','io:conf');

          e.network.ensureBinding('*','io:path','rd','io:path');
          e.network.ensureBinding('*','io:path','wd','io:path');

          e.network.ensureBinding('*','io:readkick','rd','io:kick');
          e.network.ensureBinding('*','io:writekick','wd','io:kick');
          
          e.network.ensureBinding('rd','io:stream','*','io:readStream');
          e.network.ensureBinding('*','io:writeStream','wd','io:stream');

          e.network.whenAlive.then((_){
            e.port('io:readkick').resume();
            e.port('io:writekick').resume();
          });

       });

       r.addBaseMutation('protocols/_virtualFSRule','protocols/virtualfile',(e){
          e.meta('desc','component to handle all fs operations');

          var conf = e.sd.get('conf');
          
          e.network.add('spark.fs/protocols/appendfile','ap');
          e.network.add('spark.fs/protocols/openfile','op');

          e.network.ensureBinding('*','io:conf','op','io:conf');
          e.network.ensureBinding('*','io:conf','ap','io:conf');

          e.network.ensureBinding('*','io:path','op','io:path');
          e.network.ensureBinding('*','io:path','ap','io:path');

          e.network.ensureBinding('*','io:readkick','op','io:kick');
          e.network.ensureBinding('*','io:writekick','ap','io:kick');
          
          e.network.ensureBinding('op','io:stream','*','io:readStream');
          e.network.ensureBinding('*','io:writeStream','ap','io:stream');
          
          e.network.ensureBinding('op','io:errors','*','io:errors');
          e.network.ensureBinding('ap','io:errors','*','io:errors');

          e.network.whenAlive.then((_){
            e.port('io:readkick').resume();
            e.port('io:writekick').resume();
          });

       });

       r.addMutation('protocols/_views',(e){
          e.meta('desc','component that provides view like facility');

          e.sd.add('conf',MapDecorator.create());

          e.createProxyInport('view:conf');
          e.createProxyInport('view:fn');
          e.createProxyInport('view:req');

          e.network.add('spark.server/protocols/responseboy','rsp');

          e.network.ensureBinding('*','view:req','rsp','io:stream');
          e.network.ensureBinding('*','view:fn','rsp','io:proc');
          e.network.ensureBinding('*','view:conf','rsp','io:conf');

       });

       r.addBaseMutation('protocols/_views','protocols/viewfn',(e){
          e.meta('desc','component provides a view with a function port to set up behaviour');
       });

       r.addBaseMutation('protocols/_views','protocols/pageview',(e){
          e.meta('desc','component that provides view like facility');

          e.port('view:conf').forceCondition((n){
            if(n.containsKey('view') && n['view'] is String) return true;
            throw "View configuration must provide a view key in its configuration eg { 'view': 'detail_of_view' }";
            return false;
          });

          e.send('view:fn',(p,req){
            req.enableDefaults();
            req.on('get',(r) => req.sendFile(conf.get('view')));
          });

       });

       r.addBaseMutation('protocols/_views','protocols/vfs_file',(e){
          e.meta('desc','provides a view for a file operation');

          e.createProxyOutport('view:errors');
          e.network.add('spark.server/protocols/virtualfile','vf');
          e.network.ensureBinding('vf','io:errors','*','view:errors');

          e.send('view:fn',(p,req){
            
              if(Valids.not(p.has('writable'))) p.update('writable',false);
              if(Valids.not(p.has('readable'))) p.update('readable',true);

              req.enableDefaults();

              if(Valids.isTrue(p.get('readable'))){
                req.on('get',(f){
                  e.network.schedulePacket('vf','io:readkick',true);
                });

                e.network.tapData('vf','io:readStream',(n){
                    req.send(n);
                });

                e.network.tapEnd('vf','io:readStream',(n){
                   req.end();
                });
              }

              e.network.send('vf','io:writekick',true);

              if(Valids.isTrue(p.get('writable'))){
                e.network.send('vf','io:writekick',true);
                req.on('post',(r){
                  r.getBody().then((f){
                     e.network.send('vf','io:writeStream',f);
                  }).then((f){
                     e.network.send('vf','io:writekick',true);
                     req.end();
                  });
                });
              }

          });

          e.tap('view:conf',(n){
              var conf = n.data;
              e.network.schedulePacket('vf','io:conf',{
                  'auto': (conf.containsKey('auto') ? conf['auto'] : false),
                  'file': conf['view']
              });
          });

       });

       r.addBaseMutation('protocols/_views','protocols/vfs_dir',(e){
          e.meta('desc','provides a view for a file operation');
          e.network.add('spark.server/protocols/virtualdir','vd');

       });


     });
  }
}
