library spark_server;

import 'dart:io';
import 'dart:async';
import 'package:sparkflow/sparkflow.dart';
import 'package:spark_fs/fs.dart';
import 'package:hub/hub.dart';
import 'requests.dart';

export 'package:sparkflow/sparkflow.dart';
export 'package:spark_fs/fs.dart';
export 'requests.dart';


class Server{

  static bool isWebSocket(w) => w is WebSocket;
  static bool isHttpRequest(w) => w is HttpRequest;

  static void register(){
      
     Sparkflow.createRegistry('spark.server',(r){

       r.addMutation('protocols/http',(e){
          e.meta('desc','provies a basic dart HttpServer');

          var conf = MapDecorator.create();
          e.sd.add('dconf',{ 'host': '127.0.0.1','port':3000 });
          e.sd.add('conf',null);

          e.createSpace('debug');
          e.createSpace('io');

          e.makeInport('debug:boot',meta:{'desc':'bootsup the server with default routes'});
          e.makeInport('io:conf',meta:{ 'desc':'accepts a map of configs options eg. port, hostname/address' });
          e.makeOutport('io:server',meta:{'desc': 'sends of the server object for those who care '});
          e.makeOutport('io:req',meta:{'desc':'sends out all request generated by these server object'});
          e.makeOutport('io:error',meta:{'desc':'sends out all errors generated by these server object'});

          e.port('debug:boot').tap((n){
             e.port('io:conf').send(e.sd.get('dconf'));
          });

          e.port('io:conf').forceCondition(Valids.isMap);
          e.port('io:conf').tap((n){
            if(e.sd.has('server') && Valids.exist(e.sd.get('server'))) e.sd.get('server').close();
            var cf = Enums.merge(n.data,e.sd.get('dconf'),override:false);
            conf.storage = cf;
            e.sd.update('conf',cf);
            HttpServer.bind(conf.get('host'),conf.get('port')).then((s){
               e.sd.update('server',s);
               e.port('io:server').send(s);
               s.listen((r){
                 e.port('io:req').send(r);
                 e.port('io:server').end();
               });
            }).catchError(e.port('io:error').send);
          });

          e.loopPorts('static:option','io:conf');
       });

       r.addMutation('protocols/websocks',(e){
          e.meta('desc','turns every request into a websocket to be send off');

          e.createSpace('conf');
          e.createSpace('io');

          e.makeInport('conf:meta',meta:{});
          e.makeInport('io:req',meta:{});
          e.makeInport('io:error',meta:{});
          e.makeOutport('io:socket',meta:{});
           
          e.sd.add('sockets',[]);
          e.sd.add('conf',{
            'max':10000000000000,
          });

          e.port('io:req').forceCondition(Server.isHttpRequest);
          e.port('io:req').forceCondition((n){
             if(e.sd.get('sockets').length >= e.sd.get('conf')['max']) return false;
             return true;
          });

          e.port('conf:meta').tap((n){
             if(e.sd.get('sockets').length >= e.sd.get('conf')['max']);
          });

          e.port('io:req').tap((n){
              WebSocketTransformer.upgrade(n.data).then((w){
                e.sd.get('sockets').add(w);
                e.port('io:socket').send(w);
              }).catchError(e.port('io:error').send);
              e.port('io:req').end();
          });


          e.loopPorts('static:option','conf:meta');
       });


       r.addMutation('protocols/websockboy',(e){
          e.meta('desc','lowe level websocket operation component');

          e.createSpace('io');
          e.makeInport('io:socks');
          e.makeInport('io:processor');
          e.makeOutport('io:stream');

          e.sd.add('_proc',(r){ e.sd.get('processor')(r,e); });
          e.sd.add('processor',(e,m){ return null; });

          e.port('io:processor').forceCondition(Valids.isFunction);
          e.port('io:socks').tap((n){
            e.sd.update('processor',n.data);
          });

          e.port('io:socks').forceCondition(Server.isWebSocket);
          e.port('io:socks').forceCondition((m) => Valids.notExist(e.sd.has('socket')));
          e.port('io:socks').tap((n){
            e.sd.update('socket',n.data);
            n.data.listen(e.sd.get('_proc'));
          });

          e.loopPorts('static:option','io:processor');
       });

       r.addMutation('protocols/routeboy',(e){
          e.meta('desc','filters request dependent on paramters passed');

          e.createSpace('io');
          e.makeInport('io:reqs');
          e.makeInport('io:params');
          e.makeOutport('io:stream');

          e.loopPorts('static:option','io:params');

          var param = MapDecorator.create();
          e.port('io:params').forceCondition(Valids.isMap);
          e.port('io:params').forceCondition((m){
            if(m.containsKey('route') && m['route'] is RegExp) return true;
            return false;
          });

          e.port('io:params').tap((n){
            e.sd.update('param',n.data);
            param.storage = n.data;
          });

          e.port('io:reqs').forceCondition((r){
            if(param.get('route').hasMatch(r.uri.path)) return true;
            return false;
          });

          e.port('io:reqs').bindPort(e.port('io:stream'));
       });

       r.addMutation('protocols/responseboy',(e){
          e.meta('desc','filters request dependent on paramters passed');
  
          var req = Rio.create(), 
              param = MapDecorator.create();

          e.createSpace('io');

          e.sd.add('req',req);
          e.makeInport('io:conf');
          e.makeInport('io:proc');
          e.makeInport('io:stream');

          e.loopPorts('static:option','io:conf');

          e.port('io:conf').forceCondition(Valids.isMap);
          e.port('io:proc').forceCondition(Valids.isFunction);

          e.port('io:conf').tap((n){
            e.sd.update('conf',n.data);
            param.storage = n.data;
          });

          e.port('io:stream').pause();

          e.port('io:proc').tap((n){
            e.sd.update('proc',n.data);
            e.port('io:stream').resume();
          });

          e.port('io:streams').tap((n){
            req.use(n.data);
            e.sd.get('proc')(param,req);
          });


          e.port('io:reqs').bindPort(e.port('io:stream'));
       });

       r.addMutation('protocols/viewboy',(e){
          e.meta('desc','component to handle all fs operations');

          e.enableSubnet();
          e.sd.add('conf',MapDecorator.create());
          e.createSpace('view');
          e.makeInport('view:conf');

          e.network.add('spark.server/protocols/responseboy','rsp');

       });

       r.addMutation('protocols/virtualdir',(e){
          e.meta('desc','component to handle all fs operations');

          e.sd.add('conf',MapDecorator.create());
          var conf = e.sd.get('conf');
          
          e.createSpace('io');
          e.makeInport('io:conf');
          e.makeOutport('io:stream');



          
       });

       r.addMutation('protocols/virtualfile',(e){
          e.meta('desc','component to handle all fs operations');

          e.sd.add('conf',MapDecorator.create());
          var conf = e.sd.get('conf');
          
          e.createSpace('io');
          e.makeInport('io:conf');
          e.makeOutport('io:stream');
          
       });

     });
  }
}
