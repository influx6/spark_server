library spark_server;

import 'dart:io';
import 'dart:async';
import 'dart:convert';
import 'package:sparkflow/sparkflow.dart';
import 'package:spark_fs/fs.dart';
import 'package:rio/rio.dart';
import 'package:hub/hub.dart';

export 'package:rio/rio.dart';
export 'package:sparkflow/sparkflow.dart';
export 'package:spark_fs/fs.dart';


class Server{

  static bool isWebSocket(w) => w is WebSocket;
  static bool isHttpRequest(w) => w is HttpRequest;

  static void register(){
      
     Fs.register();

     Sparkflow.createRegistry('spark.server',(r){

       r.addMutation('protocols/iojson',(v){
          v.meta('desc','generates a json response');

          var json = MapDecorator.useMap({
            'data':[]
          });

          v.makeInport('io:template');
          v.makeInport('io:data');
          v.makeOutport('io:json');

          v.port('io:template').forceCondition(Valids.isMap);

          v.port('io:data').pause();

          v.tap('io:template',(n){
             n.data.forEach((k,v){
                if(Valids.match(k,'data')) return null;
                return json.update(k,v);
             });
            v.port('io:data').resume();
          });

          v.tapData('io:data',(n){
            json.get('data').add(n.data);
          });

          v.tapEnd('io:data',(n){
            v.port('io:json').send(JSON.encode(json.core));
            v.port('io:json').endStream();
            json.get('data').clear();
          });

       });

       r.addMutation('utils/serverConsole',(e){
         e.meta('desc','prints details out into the console');

         e.sd.add('proc',Funcs.compose((n) => e.sd.get('printer')(n),
             (n) => e.sd.get('formater')(n)));

         e.sd.add('printer',print);
         e.sd.add('formater',(n){
            var r = n.data;
            if(r is Rio) r = r.req;
            var buff = new StringBuffer();
            buff.write('HttpRequest -> Address: ${r.headers.value("host")} Method: ${r.method}');
            buff.write('\n\t URI: ${r.uri.path}');
            buff.write('\n\t RemoteAddress: ${r.connectionInfo.remoteAddress}');
            buff.write('\n\t Local Port: ${r.connectionInfo.localPort}');
            buff.write('\n\t Remote Port: ${r.connectionInfo.remotePort}');
            buff.write('\n');
            return buff.toString();
         });

         e.makeInport('in:req');
         e.makeInport('in:printer');
         e.makeInport('in:formater');

         e.port('in:printer').forceCondition(Valids.isFunction);
         e.port('in:formater').forceCondition(Valids.isFunction);
         e.port('in:req').forceCondition(Server.isHttpRequest);

         e.tap('in:printer',(n){
            e.sd.update('printer',n.data);
         });
         
         e.tap('in:formater',(n){
            e.sd.update('formater',n.data);
         });

         e.tap('in:req',e.sd.get('proc'));

       });

       r.addMutation('protocols/http',(e){
          e.meta('desc','provies a basic dart HttpServer');

          var conf = MapDecorator.create();
          e.sd.add('dconf',{ 'host': '127.0.0.1','port':3000 });
          e.sd.add('conf',null);

          e.makeOutport('io:req',meta:{'desc':'sends out all request generated by these server object'});
          e.makeInport('debug:boot',meta:{'desc':'bootsup the server with default routes'});
          e.makeInport('io:conf',meta:{ 
            'desc':'accepts a map of configs options eg. port, hostname/address'
          });
          e.makeOutport('io:server',meta:{'desc': 'sends of the server object for those who care '});
          e.makeOutport('io:error',meta:{'desc':'sends out all errors generated by these server object'});

          e.port('debug:boot').tap((n){
             e.port('io:conf').send(e.sd.get('dconf'));
          });

          e.port('io:conf').forceCondition(Valids.isMap);
          e.port('io:conf').forceCondition((n){
            if(n.containsKey('port')){
              if(n['port'] is int) return true;
              e.send('io:error',"""
                "$n , port must be a number eg 4000,300";
              """);
              return false;
            }
          });

          e.port('io:conf').tap((n){
            if(e.sd.has('server') && Valids.exist(e.sd.get('server'))) e.sd.get('server').close();
            var cf = Enums.merge(n.data,e.sd.get('dconf'),override:false);
            conf.storage = cf;
            e.sd.update('conf',cf);

            HttpServer.bind(conf.get('host'),conf.get('port')).then((s){
               e.sd.update('server',s);
               e.port('io:server').send(s);
               s.listen((r){
                 e.port('io:req').send(r);
                 e.port('io:server').endStream();
               });
            }).catchError(e.port('io:error').send);
          });

       });

       r.addMutation('protocols/websocks',(e){
          e.meta('desc','turns every request into a websocket to be send off');

          e.createSpace('conf');
          e.createSpace('io');

          e.makeInport('conf:meta',meta:{});
          e.makeInport('io:req',meta:{});
          e.makeInport('io:error',meta:{});
          e.makeOutport('io:socket',meta:{});
           
          e.sd.add('sockets',[]);
          e.sd.add('conf',{
            'max':10000000000000,
          });

          e.port('io:req').forceCondition(Server.isHttpRequest);
          e.port('io:req').forceCondition((n){
             if(e.sd.get('sockets').length >= e.sd.get('conf')['max']) return false;
             return true;
          });

          e.port('conf:meta').tap((n){
             if(e.sd.get('sockets').length >= e.sd.get('conf')['max']);
          });

          e.port('io:req').tap((n){
              WebSocketTransformer.upgrade(n.data).then((w){
                e.sd.get('sockets').add(w);
                e.port('io:socket').send(w);
              }).catchError(e.port('io:error').send);
              e.port('io:req').endStream();
          });


       });


       r.addMutation('protocols/websockboy',(e){
          e.meta('desc','lowe level websocket operation component');

          e.createSpace('io');
          e.makeInport('io:socks');
          e.makeInport('io:processor');
          e.makeOutport('io:stream');

          e.sd.add('_proc',(r){ e.sd.get('processor')(r,e); });
          e.sd.add('processor',(e,m){ return null; });

          e.port('io:processor').forceCondition(Valids.isFunction);
          e.port('io:socks').tap((n){
            e.sd.update('processor',n.data);
          });

          e.port('io:socks').forceCondition(Server.isWebSocket);
          e.port('io:socks').forceCondition((m) => Valids.notExist(e.sd.has('socket')));
          e.port('io:socks').tap((n){
            e.sd.update('socket',n.data);
            n.data.listen(e.sd.get('_proc'));
          });

       });

       r.addMutation('protocols/routeboy',(e){
          e.meta('desc','filters request dependent on paramters passed');

          e.createSpace('io');
          e.makeInport('io:req');
          e.makeInport('io:conf');
          e.makeOutport('io:stream');
          e.makeOutport('io:routekey');

          var param = MapDecorator.create();
          e.port('io:conf').forceCondition(Valids.isMap);
          e.port('io:conf').forceCondition((m){
            if(m.containsKey('route') && m['route'] is RegExp) return true;
            return false;
          });

          e.port('io:conf').tap((n){
            e.sd.update('param',n.data);
            param.storage = n.data;
            e.send('io:routekey',param.get('route'));
          });

          e.port('io:req').forceCondition((r){
            if(param.get('route').hasMatch(r.uri.path)) return true;
            return false;
          });

          e.port('io:req').bindPort(e.port('io:stream'));
       });

       r.addMutation('protocol/antiroutes',(e){
  
          var list = [];
          e.sd.update('list',list);

          e.createInport('io:routes');
          e.createInport('io:req');
          e.createOutport('io:stream');

          e.port('io:routes').forceCondition(Valids.isRegExp);
          e.port('io:req').forceCondition(Server.isHttpRequest);

          e.tap('io:routes',(n){
             if(!list.contains(n.data))
               list.add(n.data);
          });

          e.tap('io:req',(n){
            Enums.eachAsync(list,(e,i,o,fn){
                if(e.hasMatch(n.data)) return fn(true);
                return fn(null);
            },(_,err){
              if(Valids.exist(err)) return null;
               e.port('io:stream').send(n.data);
            });
          });

       });

       r.addMutation('protocols/responseboy',(e){
          e.meta('desc','filters request dependent on paramters passed');
  
          var req = Rio.create(), 
              param = MapDecorator.create(),
              init = (param,req) => e.sd.get('proc')(param,req);

          e.sd.add('req',req);
          e.makeInport('io:conf');
          e.makeInport('io:proc');
          e.makeInport('io:stream');

          e.loopPorts('static:option','io:conf');

          e.port('io:conf').forceCondition(Valids.isMap);
          e.port('io:proc').forceCondition(Valids.isFunction);

          e.port('io:proc').pause();

          e.port('io:conf').tap((n){
            e.sd.update('conf',n.data);
            param.storage = n.data;
            e.port('io:proc').resume();
          });

          e.port('io:stream').pause();

          e.port('io:proc').tap((n){
            e.port('io:stream').pause();
            e.sd.update('proc',n.data);
            init(param,req);
            e.port('io:stream').resume();
          });

          e.port('io:stream').tap((n){
            req.use(n.data);
          });

       });

       r.addMutation('protocols/_virtualFSRule',(e){

          e.sd.add('conf',MapDecorator.create());
          var conf = e.sd.get('conf');
          
          e.createSpace('io');

          e.createProxyOutport('io:errors');

          e.createProxyInport('io:conf');
          e.createProxyInport('io:path');

          e.createProxyInport('io:readkick');
          e.createProxyInport('io:writekick');

          e.createProxyOutport('io:readStream');
          e.createProxyInport('io:writeStream');

          e.port('io:readkick').pause();
          e.port('io:writekick').pause();

       });

       r.addBaseMutation('protocols/_virtualFSRule','protocols/virtualdir',(e){
          e.meta('desc','component to handle all fs operations');

          var conf = e.sd.get('conf');

          e.network.add('spark.fs/protocols/opendir','rd');
          e.network.add('spark.fs/protocols/writedir','wd');

          e.network.ensureBinding('*','io:conf','rd','io:conf');
          e.network.ensureBinding('*','io:conf','wd','io:conf');

          e.network.ensureBinding('*','io:path','rd','io:path');
          e.network.ensureBinding('*','io:path','wd','io:path');

          e.network.ensureBinding('*','io:readkick','rd','io:kick');
          e.network.ensureBinding('*','io:writekick','wd','io:kick');
          
          e.network.ensureBinding('rd','io:stream','*','io:readStream');
          e.network.ensureBinding('*','io:writeStream','wd','io:stream');

          e.network.ensureBinding('rd','io:error','*','io:errors');
          e.network.ensureBinding('wd','io:error','*','io:errors');

          e.network.whenAlive.then((_){
            e.port('io:readkick').resume();
            e.port('io:writekick').resume();
          });

       });

       r.addBaseMutation('protocols/_virtualFSRule','protocols/virtualfile',(e){
          e.meta('desc','component to handle all fs operations');

          var conf = e.sd.get('conf');
          
          e.network.add('spark.fs/protocols/appendfile','ap');
          e.network.add('spark.fs/protocols/openfile','op');

          e.network.ensureBinding('*','io:conf','op','io:conf');
          e.network.ensureBinding('*','io:conf','ap','io:conf');

          e.network.ensureBinding('*','io:path','op','io:path');
          e.network.ensureBinding('*','io:path','ap','io:path');

          e.network.ensureBinding('*','io:readkick','op','io:kick');
          e.network.ensureBinding('*','io:writekick','ap','io:kick');
          
          e.network.ensureBinding('op','io:stream','*','io:readStream');
          e.network.ensureBinding('*','io:writeStream','ap','io:stream');
          
          e.network.ensureBinding('op','io:error','*','io:errors');
          e.network.ensureBinding('ap','io:error','*','io:errors');

          e.network.whenAlive.then((_){
            e.port('io:readkick').resume();
            e.port('io:writekick').resume();
            e.port('io:conf').resume();
          });

       });

       r.addMutation('protocols/_baseview',(e){
          e.meta('desc','component that provides view like facility');

          e.sd.add('conf',MapDecorator.create());

          var req = Rio.create();
          req.enableDefaults();
          e.sd.update('req',req);

          e.createProxyInport('view:fn');
          e.createProxyInport('view:conf');
          e.createProxyInport('view:req');
          e.createProxyOutport('view:errors');

          e.port('view:fn').forceCondition(Valids.isFunction);
          e.port('view:conf').forceCondition(Valids.isMap);
          e.port('view:req').forceCondition(Server.isHttpRequest);

          e.tapData('view:conf',(n){
            e.sd.get('conf').storage = n.data;
          });

          e.tapData('view:req',(n){
            req.use(n.data);
          });
       });

       r.addBaseMutation('protocols/_baseview','protocols/_ioBaseView',(e){

            var conf = e.sd.get('conf');
            e.sd.update('ioconf',MapDecorator.create());

            e.tapData('view:conf',(n){ var conf = e.sd.get('conf');
                if(Valids.not(conf.has('writable'))) conf.update('writable',false);
                if(Valids.not(conf.has('readable'))) conf.update('readable',true);
            });

            e.tapData('view:conf',(n){
               var fs = {
                  'auto': (conf.has('auto') ? conf.get('auto') : false),
                  'file': conf.get('view')
              };
              e.sd.get('ioconf').storage = fs;
            });

            e.tapData('view:fn',(n){
              n.data(e.sd.get('req'));
            });

       });

       r.addBaseMutation('protocols/_baseview','protocols/_responseboy_viewbase',(e){
          e.meta('desc','component that provides view like facility');

          e.network.add('spark.server/protocols/responseboy','rsp');

          e.network.ensureBinding('*','view:req','rsp','io:stream');
          e.network.ensureBinding('*','view:fn','rsp','io:proc');
          e.network.ensureBinding('*','view:conf','rsp','io:conf');
       });

       r.addBaseMutation('protocols/_responseboy_viewbase','protocols/viewfn',(e){
          e.meta('desc','provides a view with a function port to set up behaviour');
       });

       r.addBaseMutation('protocols/_responseboy_viewbase','protocols/pageview',(e){
          e.meta('desc','provides view rendering a file eg index.html');

          e.port('view:conf').forceCondition((n){
            if(n.containsKey('view') && n['view'] is String) return true;
            e.send('view:errors',"""
              View config must provide a value for view eg { 'view': 'detail_of_view' }
            """);
            return false;
          });

          e.send('view:fn',(p,req){
            req.enableDefaults();
            req.on('get',(r) => req.sendFile(conf.get('view')));
          });

       });

       r.addMutation('protocols/response_reader',(e){

         e.makeInport('io:req');
         e.makeOutport('io:stream');

         e.tap('io:req',(n){
              e.port('io:req').pause();
              var req = n.data;
              req.getBody().then((f){
                e.port('io:stream').send(f);
                e.port('io:stream').endStream();
                req.end();
              });
         });

         e.tapEnd('io:stream',(n){
            e.port('io:req').resume();
         });

       });

       r.addMutation('protocols/response_writer',(e){

         e.makeInport('io:req');
         e.makeInport('io:stream');

         e.port('io:stream').pause();

         e.tap('io:req',(n){
              e.sd.update('req',n.data);
              e.port('io:req').pause();
              e.port('io:stream').resume();
         });

         e.tapData('io:stream',(n){
              e.sd.get('req').send(n.data);
         });

         e.tapEnd('io:stream',(n){
            e.sd.get('req').end();
            e.port('io:req').resume();
         });

       });

       r.addBaseMutation('protocols/_ioBaseView','protocols/_ioViewStream',(e){
          e.meta('desc','provides a view for a file operation');

          e.createProxyOutport('view:reqStream');
          e.createProxyOutport('view:writedata');
          e.createProxyInport('view:readdata');

          e.network.add('spark.server/protocols/response_writer','rw');
          e.network.add('spark.server/protocols/response_reader','rd');

          e.network.ensureBinding('*','view:writedata','rw','io:stream');
          e.network.ensureBinding('rd','io:stream','*','view:readdata');

          var req = e.sd.get('req');

          req.on('head',(f){
              e.send('view:reqStream',req);
              req.end();
          });

          req.on('get',(f){
            if(Valids.isTrue(e.sd.get('conf').get('readable'))){
                e.send('view:reqStream',req);
                e.network.send('rw','io:req',req);
             }
          });

          req.on('post',(r){
            if(Valids.isTrue(e.sd.get('conf').get('writable'))){
              e.send('view:reqStream',req);
              e.network.send('rd','io:req',req);
             }
          });

          req.on('put',(r){
            if(Valids.isTrue(e.sd.get('conf').get('writable'))){
              e.send('view:reqStream',req);
              e.network.send('rd','io:req',req);
             }
          });

       });

       r.addBaseMutation('protocols/_ioViewStream','protocols/ioview',(e){

            var conf = e.sd.get('conf');

            e.network.add('spark.utils/utils/utf8.decode','ud');
            e.network.add('spark.utils/utils/utf8.decode','ud2');

            e.createProxyOutport('io:outstream');
            e.createProxyInport('io:instream');

            e.network.ensureBinding('*','view:readdata','ud2','io:in');
            e.network.ensureBinding('ud2','io:out','*','io:outstream');

            e.network.ensureBinding('*','io:instream','ud','io:in');
            e.network.ensureBinding('ud','io:out','*','view:writedata');

       });

       r.addBaseMutation('protocols/_iobaseView','protocols/fileview',(e){

            var conf = e.sd.get('conf');

            e.network.add('spark.server/protocols/virtualfile','vd');
            e.network.add('spark.server/protocols/ioview','vio');
            e.network.add('spark.server/protocols/iojson','jsn');
            e.network.add('spark.utils/utils/utf8.encode','u8');

            e.network.ensureBinding('*','view:req','vio','view:req');
            e.network.ensureBinding('*','view:conf','vio','view:conf');

            e.network.ensureBinding('vd','io:errors','*','view:errors');
            e.network.ensureBinding('vd','io:readStream','jsn','io:data');
            e.network.ensureBinding('jsn','io:json','u8','io:in');
            e.network.ensureBinding('u8','io:out','vio','io:instream');
            e.network.ensureBinding('vio','io:outstream','vd','io:writeStream');

            e.network.filter('jsn').then((_){
              _.port('io:data').mixedTransformer.on((n){
                  if(!Valids.match(n.event,"data")) return n;
                  n.data = UTF8.decode(n.data is List ? n.data : [n.data]);
                  return n;
              });
            });

            e.network.schedulePacket('jsn','io:template',{
              'component':"spark.server/protocols/fileview",
              'format':'file_json',
              'version':'0.1',
              'spec':null,
              'description':'provides a nice json response for file stream'
            });

            e.send('view:fn',(req){

                req.on('get',(r){
                    if(conf.get('readable'))
                      e.network.send('vd','io:readkick',true);
                });

                req.on('post',(r){
                    if(conf.get('writable'))
                      e.network.send('vd','io:writekick',true);
                });

                req.on('put',(r){
                    if(conf.get('writable'))
                      e.network.send('vd','io:writekick',true);
                });

            });
              
            e.tapData('view:conf',(n){
                e.network.schedulePacket('vd','io:conf',e.sd.get('ioconf').core);
            });

       });


       r.addBaseMutation('protocols/_ioBaseView','protocols/dirview',(e){

            var conf = e.sd.get('conf');

            e.network.add('spark.server/protocols/virtualdir','vd');
            e.network.add('spark.server/protocols/ioview','vio');
            e.network.add('spark.server/protocols/iojson','jsn');
            e.network.add('spark.utils/utils/utf8.encode','u8');

            e.network.filter('jsn').then((_){
              _.port('io:data').mixedTransformer.on((n){
                  if(!Valids.match(n.event,"data")) return n;
                  var data = n.data, map = {
                    'path': data.path,
                    'basepath': Fs.bitShiftPath(data.path)
                  };
                  if(data is Directory) map['type'] = 'directory';
                  if(data is File) map['type'] = 'file';
                  n.data = map;
                  return n;
              });
            });

            e.network.ensureBinding('*','view:req','vio','view:req');
            e.network.ensureBinding('*','view:conf','vio','view:conf');

            e.network.ensureBinding('vd','io:errors','*','view:errors');
            e.network.ensureBinding('vd','io:readStream','jsn','io:data');
            e.network.ensureBinding('jsn','io:json','u8','io:in');
            e.network.ensureBinding('u8','io:out','vio','io:instream');
            e.network.ensureBinding('vio','io:outstream','vd','io:writeStream');

            e.network.schedulePacket('jsn','io:template',{
              'component':"spark.server/protocols/dirview",
              'format':'dir_json',
              'version':'0.1',
              'spec':null,
              'description':'provides a nice json response for dir lists'
            });

            e.tapData('view:conf',(n){
                e.network.schedulePacket('vd','io:conf',e.sd.get('ioconf').core);
            });

            e.send('view:fn',(req){

                req.on('get',(r){
                    if(conf.get('readable'))
                      e.network.send('vd','io:readkick',true);
                });

                req.on('post',(r){
                    if(conf.get('writable'))
                      e.network.send('vd','io:writekick',true);
                });

                req.on('put',(r){
                    if(conf.get('writable'))
                      e.network.send('vd','io:writekick',true);
                });

            });

       });

       r.addBaseMutation('protocols/_ioBaseView','protocols/vfs',(e){

            var conf = e.sd.get('conf');
            var req = e.sd.get('req');

            req.enableDefaults();

            e.network.add('spark.server/protocols/dirview','dv');
            e.network.add('spark.server/protocols/fileview','fv');

            e.network.add('spark.fs/protocols/isFile','isf');
            e.network.add('spark.fs/protocols/isDirectory','isd');
            e.network.add('spark.fs/protocols/pathModShift','psm');

            e.network.ensureBinding('isf','io:no','*','view:errors');
            e.network.ensureBinding('isd','io:no','*','view:errors');

            e.tapData('view:conf',(n){
              conf.update('writable',false);
              e.network.schedulePacket('psm','io:root',conf.get('view'));
            });

            e.network.tap('isf','io:yes',(n){
                var file = new Map.from(conf.core); file['view'] =  n.data;
                e.network.send('fv','view:conf',file).then((_){
                  e.network.schedulePacket('fv','view:req',req.req);
                });
            });

            e.network.tap('isd','io:yes',(n){
                var dir = new Map.from(conf.core); dir['view'] =  n.data;
                e.network.send('dv','view:conf',dir).then((_){
                  e.network.schedulePacket('dv','view:req',req.req);
                });
            });

            e.network.tap('psm','io:mods',(n){
               e.network.schedulePacket('isf','io:path',n);
               e.network.schedulePacket('isd','io:path',n);
            });

            e.send('view:fn',(req){
                req.on('get',(b){
                   e.network.schedulePacket('psm','io:paths',req.url);
                });
            });

            e.network.send('psm','io:conf',{ 'lock':true });

       });

     });

  }
}
